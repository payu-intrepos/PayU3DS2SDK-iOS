// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name PayU3DS2CoreKit
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AdSupport
import CoreLocation
import Darwin
import Foundation
@_exported import PayU3DS2CoreKit
import Security
import Swift
import SystemConfiguration
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
extension PayU3DS2CoreKit.WFChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@objc public class Warning : ObjectiveC.NSObject {
  @objc public enum Severity : Swift.Int {
    case LOW
    case MEDIUM
    case HIGH
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum WarnReason : Swift.String {
    case SW01
    case SW02
    case SW03
    case SW04
    case SW05
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var id: Swift.String
  public var message: Swift.String
  public var severity: PayU3DS2CoreKit.Warning.Severity
  @objc public init(id: Swift.String, message: Swift.String, severity: PayU3DS2CoreKit.Warning.Severity)
  @objc public func getID() -> Swift.String
  @objc public func getMessage() -> Swift.String
  @objc public func getSeverity() -> PayU3DS2CoreKit.Warning.Severity
  @objc deinit
}
public struct WFOFB : PayU3DS2CoreKit.WFBlockMode {
  public enum WFError : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PayU3DS2CoreKit.WFOFB.WFError, b: PayU3DS2CoreKit.WFOFB.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PayU3DS2CoreKit.WFBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
extension PayU3DS2CoreKit.WFAES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: PayU3DS2CoreKit.WFPadding = .pkcs7) throws
}
@objc open class PArs : ObjectiveC.NSObject, Swift.Codable {
  @objc open var p_messageVersion: Swift.String?
  @objc open var threeDSServerTransID: Swift.String?
  @objc open var threeDSServerRefNumber: Swift.String?
  @objc open var acsTransID: Swift.String?
  @objc open var acsEphemPubKey: Swift.String?
  @objc open var acsReferenceNumber: Swift.String?
  @objc open var authenticationValue: Swift.String?
  @objc open var dsReferenceNumber: Swift.String?
  @objc open var dsTransID: Swift.String?
  @objc open var sdkTransID: Swift.String?
  @objc open var eci: Swift.String?
  @objc open var messageType: Swift.String?
  @objc open var transStatus: Swift.String?
  @objc open var acsRenderingType: PayU3DS2CoreKit.AcsRenderingType?
  @objc open var acsSignedContent: Swift.String?
  @objc open var acsURL: Swift.String?
  @objc open var authenticationType: Swift.String?
  @objc open var acschallengeMandated: Swift.String?
  @objc open var transStatusReason: Swift.String?
  @objc open var errorMessageType: Swift.String?
  @objc open var errorDescription: Swift.String?
  @objc open var errorCode: Swift.String?
  @objc open var errorComponent: Swift.String?
  @objc open var errorDetail: Swift.String?
  @objc open var messageVersion: Swift.String?
  public typealias buildPArsClosure = (PayU3DS2CoreKit.PArs) -> Swift.Void
  @objc public init(build: (PayU3DS2CoreKit.PArs) -> Swift.Void)
  @objc public init(json: [Swift.String : Any]) throws
  @objc deinit
  open func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol WFBlockMode {
  var options: PayU3DS2CoreKit.WFBlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
@objc @_inheritsConvenienceInitializers public class InvalidInputException : PayU3DS2CoreKit.RuntimeException {
  @objc override public init(message: Swift.String, cause: Swift.String?)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class WFCBCMAC : PayU3DS2CoreKit.WFCMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
@objc public class CompletionEvent : ObjectiveC.NSObject {
  @objc public var sdkTransactionID: Swift.String
  @objc public var transactionStatus: Swift.String
  @objc public init(sdkTransactionID: Swift.String, transactionStatus: Swift.String)
  @objc public func getSDKTransactionID() -> Swift.String
  @objc public func getTransactionStatus() -> Swift.String
  @objc deinit
}
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPayULogo()
  @objc @_Concurrency.MainActor(unsafe) dynamic public func removePayULogo()
  @objc @_Concurrency.MainActor(unsafe) dynamic public func showPayULoader(message: Swift.String = "", backgroundColor: UIKit.UIColor = .white, alpha: CoreFoundation.CGFloat = 1.0)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func showPayULoader(with message: Swift.String = "", and backgroundColor: UIKit.UIColor = .white)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func hidePayULoader()
}
@objc public class ProtocolErrorEvent : ObjectiveC.NSObject {
  @objc public var sdkTransactionID: Swift.String
  @objc public var errorMessage: PayU3DS2CoreKit.ErrorMessage
  @objc public init(_ sdkTransactionID: Swift.String, _ errorMessage: PayU3DS2CoreKit.ErrorMessage)
  @objc public func getErrorMessage() -> Swift.String
  @objc public func getSDKTransactionID() -> Swift.String
  @objc deinit
}
extension PayU3DS2CoreKit.WFAES : PayU3DS2CoreKit.WFCryptors {
  @inlinable final public func makeEncryptor() throws -> PayU3DS2CoreKit.WFCryptor & PayU3DS2CoreKit.WFUpdatable {
    let blockSize = blockMode.customBlockSize ?? WFAES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is WFStreamModeWorker {
      return try WFStreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try WFBlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> PayU3DS2CoreKit.WFCryptor & PayU3DS2CoreKit.WFUpdatable {
    let blockSize = blockMode.customBlockSize ?? WFAES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is WFStreamModeWorker {
      return try WFStreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try WFBlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
@objc public class SDKRuntimeException : PayU3DS2CoreKit.RuntimeException {
  public var errorCode: Swift.String? {
    get
  }
  @objc public init(message: Swift.String, errorCode: Swift.String?, cause: Swift.String?)
  @objc public func getErrorCode() -> Swift.String?
  @objc deinit
}
public enum WFPKCS7 {
}
public class PArq : Swift.Codable {
  public var messageVersion: Swift.String?
  public var p_messageVersion: Swift.String?
  public var threeDSRequestorID: Swift.String?
  public var threeDSRequestor3RIInd: Swift.String?
  public var threeDSRequestorName: Swift.String?
  public var threeDSRequestorURL: Swift.String?
  public var threeDSServerRefNumber: Swift.String?
  public var threeDSServerTransID: Swift.String?
  public var threeDSServerURL: Swift.String?
  public var acquirerBIN: Swift.String?
  public var acquirerMerchantID: Swift.String?
  public var addrMatch: Swift.String?
  public var cardExpiryDate: Swift.String?
  public var billAddrCity: Swift.String?
  public var billAddrCountry: Swift.String?
  public var billAddrLine1: Swift.String?
  public var billAddrLine2: Swift.String?
  public var billAddrLine3: Swift.String?
  public var billAddrPostCode: Swift.String?
  public var billAddrState: Swift.String?
  public var email: Swift.String?
  public var homePhone: Swift.String?
  public var mobilePhone: Swift.String?
  public var cardholderName: Swift.String?
  public var shipAddrCity: Swift.String?
  public var shipAddrCountry: Swift.String?
  public var shipAddrLine1: Swift.String?
  public var shipAddrLine2: Swift.String?
  public var shipAddrLine3: Swift.String?
  public var acctNumber: Swift.String?
  public var shipAddrPostCode: Swift.String?
  public var shipAddrState: Swift.String?
  public var workPhone: Swift.String?
  public var deviceChannel: PayU3DS2CoreKit.DeviceChannel?
  public var deviceInfo: Swift.String?
  public var deviceRenderOptions: PayU3DS2CoreKit.DeviceRenderOptions?
  public var dsReferenceNumber: Swift.String?
  public var dsTransID: Swift.String?
  public var dsURL: Swift.String?
  public var mcc: Swift.String?
  public var merchantCountryCode: Swift.String?
  public var merchantName: Swift.String?
  public var messageCategory: PayU3DS2CoreKit.MessageCategory?
  public var messageType: PayU3DS2CoreKit.MessageType?
  public var purchaseAmount: Swift.String?
  public var purchaseCurrency: Swift.String?
  public var purchaseExponent: Swift.String?
  public var purchaseDate: Swift.String?
  public var sdkAppID: Swift.String?
  public var sdkEncData: Swift.String?
  public var sdkEphemPubKey: PayU3DS2CoreKit.SdkEphemPubKey?
  public var sdkReferenceNumber: Swift.String?
  public var sdkTransID: Swift.String?
  public var transType: PayU3DS2CoreKit.TransactionType?
  public var dsRefNumber: Swift.String?
  public var sdkMaxTimeout: Swift.String?
  public var threeDSRequestorAuthenticationInd: Swift.String?
  public typealias builder = (PayU3DS2CoreKit.PArq) -> Swift.Void
  public init(build: (PayU3DS2CoreKit.PArq) -> Swift.Void)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension PayU3DS2CoreKit.WFPKCS5 {
  public struct WFPBKDF2 {
    public enum WFError : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: PayU3DS2CoreKit.WFPKCS5.WFPBKDF2.WFError, b: PayU3DS2CoreKit.WFPKCS5.WFPBKDF2.WFError) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: PayU3DS2CoreKit.WFHMAC.WFVariant = .sha2(.sha256)) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
    public func callAsFunction() throws -> Swift.Array<Swift.UInt8>
  }
}
public struct WFCCM {
  public enum WFError : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: PayU3DS2CoreKit.WFCCM.WFError, b: PayU3DS2CoreKit.WFCCM.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PayU3DS2CoreKit.WFBlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
}
@objc public class RuntimeErrorEvent : ObjectiveC.NSObject {
  @objc public var errorCode: Swift.String?
  @objc public var errorMessage: Swift.String
  @objc public init(_ errorCode: Swift.String?, _ errorMessage: Swift.String)
  @objc public func getErrorMessage() -> Swift.String
  @objc public func getErrorCode() -> Swift.String?
  @objc deinit
}
public enum AcsInterface : Swift.String, Swift.Codable {
  case native
  case html
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AcsUiTemplate : Swift.String, Swift.Codable {
  case text
  case singleSelect
  case multiSelect
  case oob
  case html
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @objc open class AcsRenderingType : ObjectiveC.NSObject, Swift.Codable {
  @objc open var acsInterface: Swift.String?
  @objc open var acsUiTemplate: Swift.String?
  @objc override dynamic public init()
  @objc deinit
  open func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public protocol ExceptionReceiver {
  @objc func didReceiveInvalidInputException(_ message: Swift.String)
  @objc func didReceiveInvalidAcsUITypeException(_ acsUIType: Swift.String)
}
@objc public protocol ThreeDS2Service {
  @objc func initialize(_ application: UIKit.UIApplication?, configParameters: PayU3DS2CoreKit.ConfigParameters?, locale: Swift.String?, uiCustomization: PayU3DS2CoreKit.UiCustomization?, logHandlerDelegate: PayU3DS2CoreKit.LogHandler) throws
  @objc func createTransaction(_ directoryServerID: Swift.String, messageVersion: Swift.String?) throws -> PayU3DS2CoreKit.Transaction
  @objc func cleanup() throws
  @objc func getSDKVersion() throws -> Swift.String
  @objc func getWarnings() throws -> [PayU3DS2CoreKit.Warning]
}
@objc public protocol GenericChallengeProtocol {
  @objc func clickVerifyButton()
  @objc func getChallengeType() -> Swift.String
  @objc func clickCancelButton()
  @objc func setChallengeProtocol(sdkChallengeProtocol: PayU3DS2CoreKit.SDKChallengeProtocol)
  @objc func expandTextsBeforeScreenshot()
  @objc func selectWhitelistChecked(checked: Swift.Bool)
  @objc func setLandscapeOrientation(landscapeOrientation: Swift.Bool)
}
@objc public protocol MultiSelectChallengeProtocol : PayU3DS2CoreKit.GenericChallengeProtocol {
  @objc func selectIndex(_ index: Swift.Int)
}
@objc public protocol OutOfBandChallengeProtocol : PayU3DS2CoreKit.GenericChallengeProtocol {
}
@objc public protocol SDKChallengeProtocol {
  @objc func handleChallenge()
}
@objc public protocol SingleSelectorChallengeProtocol : PayU3DS2CoreKit.GenericChallengeProtocol {
  @objc func selectObject(_ index: Swift.Int)
}
@objc public protocol TextChallengeProtocol : PayU3DS2CoreKit.GenericChallengeProtocol {
  @objc func typeTextChallengeValue(_ value: Swift.String)
}
@objc public protocol WebChallengeProtocol : PayU3DS2CoreKit.GenericChallengeProtocol {
  @objc func getWebView() -> WebKit.WKWebView
}
@_inheritsConvenienceInitializers @objc public class ConfigParameters : ObjectiveC.NSObject {
  @objc public var params: [Swift.String : [Swift.String : Swift.String]]
  @objc override dynamic public init()
  @objc public func addParam(_ group: Swift.String?, paramName: Swift.String?, paramValue: Swift.String?) throws
  @objc public func getParamValue(_ group: Swift.String?, _ paramName: Swift.String?) throws -> Swift.String
  @objc public func removeParam(_ group: Swift.String?, _ paramName: Swift.String?) throws -> Swift.String
  @objc deinit
}
extension PayU3DS2CoreKit.ConfigParameters {
  @objc dynamic public func setAutoSubmitEnable(_ isAutoSubmitEnabled: Swift.Bool)
  @objc dynamic public func setMinOtpLength(_ otpLength: Swift.Int)
  @objc dynamic public func setTransactionId(_ txnId: Swift.String)
  @objc dynamic public func setKeyboardType(_ keyboardType: UIKit.UIKeyboardType)
  @objc dynamic public func setCustomDialogLoader(_ useCustomLoader: Swift.Bool, _ color: Swift.String)
  @objc dynamic public func setResendOTPAllowCount(_ count: Swift.Int)
}
public struct DefaultConstants {
  public static let fontName: Swift.String
}
extension PayU3DS2CoreKit.WFHMAC {
  convenience public init(key: Swift.String, variant: PayU3DS2CoreKit.WFHMAC.WFVariant = .md5) throws
}
@available(*, renamed: "Digest")
public typealias Hash = PayU3DS2CoreKit.WFDigest
public struct WFDigest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: PayU3DS2CoreKit.WFSHA2.WFVariant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: PayU3DS2CoreKit.WFSHA3.WFVariant) -> Swift.Array<Swift.UInt8>
}
public enum PayULoadingType {
  case center
  case fullScreen
  public static func == (a: PayU3DS2CoreKit.PayULoadingType, b: PayU3DS2CoreKit.PayULoadingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum IndicatorType {
  case sdk
  case payU
  public static func == (a: PayU3DS2CoreKit.IndicatorType, b: PayU3DS2CoreKit.IndicatorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SDKLoadingType {
  case progress
  case logo(logoImageName: Swift.String)
}
@_inheritsConvenienceInitializers @objc public class FontFamilyCustomization : ObjectiveC.NSObject {
  @objc public var headerFontFamilyName: Swift.String
  @objc public var textFontFamilyName: Swift.String
  @objc public func setHeaderFontFamily(_ fontName: Swift.String)
  @objc public func getHeadingTextFontName() -> Swift.String
  @objc public func setTextFontFamily(_ fontName: Swift.String)
  @objc public func getTextFontFamily() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@objc public protocol Transaction {
  @objc func getAuthenticationRequestParameters() -> PayU3DS2CoreKit.AuthenticationRequestParameters
  @objc func doChallenge(_ challengeParameters: PayU3DS2CoreKit.ChallengeParameters, challengeStatusReceiver: PayU3DS2CoreKit.ChallengeStatusReceiver, timeOut: Swift.Int) throws
  @objc func getProgressView() throws -> PayU3DS2CoreKit.ProgressDialog
  @objc func close()
}
final public class WFChecksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ WFChecksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ WFChecksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ WFChecksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension PayU3DS2CoreKit.WFChecksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    WFChecksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    WFChecksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    WFChecksum().crc16(message, seed: seed)
  }
}
final public class WFMD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension PayU3DS2CoreKit.WFMD5 : PayU3DS2CoreKit.WFUpdatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc public class SDKNotInitializedException : PayU3DS2CoreKit.RuntimeException {
  @objc override public init(message: Swift.String, cause: Swift.String?)
  @objc deinit
}
@objc public class ToolbarCustomization : PayU3DS2CoreKit.Customization {
  @objc public var backgroundColor: Swift.String?
  @objc public var headerText: Swift.String?
  @objc public var buttonText: Swift.String?
  public init(backgroundColor: Swift.String? = nil, headerText: Swift.String? = nil, buttonText: Swift.String? = nil)
  public func setBackgroundColor(_ hexColorCode: Swift.String)
  public func setHeaderText(_ headerText: Swift.String)
  public func setButtonText(_ buttonText: Swift.String)
  public func getBackgroundColor() -> Swift.String?
  public func getHeaderText() -> Swift.String?
  public func getButtonText() -> Swift.String?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor(unsafe) public class PayUBaseView : UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) public var onViewDismissed: (() -> Swift.Void)?
  @objc @_Concurrency.MainActor(unsafe) public var onHeightChanged: ((CoreFoundation.CGFloat) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc deinit
}
@usableFromInline
final internal class WFBlockEncryptor : PayU3DS2CoreKit.WFCryptor, PayU3DS2CoreKit.WFUpdatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PayU3DS2CoreKit.WFPadding, _ worker: PayU3DS2CoreKit.WFCipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
@objc public class ChallengeParameters : ObjectiveC.NSObject {
  @objc public var a3DSServerTransactionID: Swift.String?
  @objc public var acsTransactionID: Swift.String?
  @objc public var acsRefNumber: Swift.String?
  @objc public var acsSignedContent: Swift.String?
  @objc public var threeDSServerTransactionID: Swift.String?
  @objc public var threeDSRequestorAppURL: Swift.String?
  public var acsRenderingType: PayU3DS2CoreKit.ACSUIType?
  @objc public init(a3DSServerTransactionID: Swift.String? = nil, acsTransactionID: Swift.String? = nil, acsRefNumber: Swift.String? = nil, acsSignedContent: Swift.String? = nil, threeDSServerTransactionID: Swift.String? = nil, threeDSRequestorAppURL: Swift.String? = nil, acsRenderingType: PayU3DS2CoreKit.ACSUITypeInt = ACSUITypeInt.unknown)
  @objc deinit
}
final public class WFGCM : PayU3DS2CoreKit.WFBlockMode {
  public enum WFMode {
    case combined
    case detached
    public static func == (a: PayU3DS2CoreKit.WFGCM.WFMode, b: PayU3DS2CoreKit.WFGCM.WFMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: PayU3DS2CoreKit.WFBlockModeOption
  public enum WFError : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: PayU3DS2CoreKit.WFGCM.WFError, b: PayU3DS2CoreKit.WFGCM.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: PayU3DS2CoreKit.WFGCM.WFMode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: PayU3DS2CoreKit.WFGCM.WFMode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
  @objc deinit
}
public enum ProtocolConstants : Swift.String {
  case TransactionStatus
  case ACSTransID
  case ACSCounterAtoS
  case HtmlVerify
  case DirectoryServerIdDev
  case DirectoryServerIdUl
  case ThreeDS2SpecVer
  case ThreeDS2ReferenceNumber
  case MasterDirectoryServerIdProd
  case VisaDirectoryServerIdProd
  case MasterAccquirerBinProd
  case VisaAccquirerBinProd
  case MasterMerchantIdProd
  case VisaMerchantIdProd
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AresTxnStatus : Swift.String, Swift.Codable {
  case authenticated
  case challenge
  case notAuthenticated
  case attempt
  case unable
  case rejected
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MessageType : Swift.String, Swift.Codable {
  case areq
  case parq
  case ares
  case pars
  case creq
  case cres
  case error
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MessageCategory : Swift.String, Swift.Codable {
  case paymentAuthentication
  case nonPaymentAuthentication
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum TransactionType : Swift.String, Swift.Codable {
  case goodServicePurchase
  case checkAcceptance
  case accountFunding
  case cashTransaction
  case activationAndLoad
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum DeviceChannel : Swift.String, Swift.Codable {
  case app
  case browser
  case ri3
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class Wibmo3ds : ObjectiveC.NSObject {
  @objc public static let shared: PayU3DS2CoreKit.Wibmo3ds
  @objc public var configParams: PayU3DS2CoreKit.ConfigParameters?
  @objc public var exceptionReceiver: PayU3DS2CoreKit.ExceptionReceiver?
  @objc public static func storyboard() -> UIKit.UIStoryboard
  @objc deinit
}
extension PayU3DS2CoreKit.Wibmo3ds : PayU3DS2CoreKit.ThreeDS2Service {
  @objc dynamic public func initialize(_ application: UIKit.UIApplication?, configParameters: PayU3DS2CoreKit.ConfigParameters?, locale: Swift.String?, uiCustomization: PayU3DS2CoreKit.UiCustomization?, logHandlerDelegate: PayU3DS2CoreKit.LogHandler) throws
  @objc dynamic public func createTransaction(_ directoryServerID: Swift.String, messageVersion: Swift.String?) throws -> PayU3DS2CoreKit.Transaction
  @objc dynamic public func cleanup() throws
  @objc dynamic public func getSDKVersion() throws -> Swift.String
  @objc dynamic public func getWarnings() throws -> [PayU3DS2CoreKit.Warning]
}
extension PayU3DS2CoreKit.Wibmo3ds {
  @objc dynamic public func loggingDictionaryForKibana(key: Swift.String, value: Swift.String = "", className: Swift.String = "", txnId: Swift.String? = nil) -> [Swift.String : Any]
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
public class WFBlockDecryptor : PayU3DS2CoreKit.WFCryptor, PayU3DS2CoreKit.WFUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: PayU3DS2CoreKit.WFPadding
  @usableFromInline
  internal var worker: PayU3DS2CoreKit.WFCipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PayU3DS2CoreKit.WFPadding, _ worker: PayU3DS2CoreKit.WFCipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? WFFinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? WFFinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? WFFinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) open class ProgressDialog : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor(unsafe) open func start()
  @objc @_Concurrency.MainActor(unsafe) open func stop()
  @objc deinit
}
@objc public class RuntimeException : ObjectiveC.NSObject, Swift.Error {
  @objc public init(message: Swift.String, cause: Swift.String?)
  @objc public func getMessage() -> Swift.String?
  @objc deinit
}
@objc public class ErrorMessage : ObjectiveC.NSObject, Swift.Codable, Swift.Error {
  @objc public var threeDSServerTransID: Swift.String
  @objc public var errorCode: Swift.String
  @objc public var errorDescription: Swift.String
  @objc public var errorDetail: Swift.String?
  @objc public var acsTransID: Swift.String?
  @objc public var errorComponent: Swift.String?
  @objc public var errorMessageType: Swift.String?
  @objc public var messageType: Swift.String?
  @objc public var messageVersion: Swift.String?
  @objc public var sdkTransID: Swift.String?
  @objc public init(_ transactionID: Swift.String, _ errorCode: Swift.String, _ errorDescription: Swift.String, _ errorDetail: Swift.String?)
  @objc public func getTransactionID() -> Swift.String
  @objc public func getErrorCode() -> Swift.String
  @objc public func getErrorDescription() -> Swift.String
  @objc public func getErrorDetails() -> Swift.String?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers open class WFSwKeyStore {
  public enum SecError : Darwin.OSStatus, Swift.Error {
    case unimplemented
    case param
    case allocate
    case notAvailable
    case authFailed
    case duplicateItem
    case itemNotFound
    case interactionNotAllowed
    case decode
    case missingEntitlement
    public static var debugLevel: Swift.Int
    public init?(rawValue: Darwin.OSStatus)
    public typealias RawValue = Darwin.OSStatus
    public var rawValue: Darwin.OSStatus {
      get
    }
  }
  public static func upsertKey(_ pemKey: Swift.String, keyTag: Swift.String, options: [Foundation.NSString : Swift.AnyObject] = [:]) throws
  public static func getKey(_ keyTag: Swift.String) throws -> Swift.String
  public static func delKey(_ keyTag: Swift.String) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers open class WFSwKeyConvert {
  public enum SwError : Swift.Error {
    case invalidKey
    case badPassphrase
    case keyNotEncrypted
    public static var debugLevel: Swift.Int
    public static func == (a: PayU3DS2CoreKit.WFSwKeyConvert.SwError, b: PayU3DS2CoreKit.WFSwKeyConvert.SwError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers open class PrivateKey {
    public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
    public typealias EncMode = PayU3DS2CoreKit.WFPEM.EncryptedPrivateKey.EncMode
    public static func encryptPEM(_ pemKey: Swift.String, passphrase: Swift.String, mode: PayU3DS2CoreKit.WFSwKeyConvert.PrivateKey.EncMode) throws -> Swift.String
    public static func decryptPEM(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Swift.String
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class PublicKey {
    public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func pemToPKCS8DER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
    public static func derToPKCS8PEM(_ derKey: Foundation.Data) -> Swift.String
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class WFPKCS8 {
  @_hasMissingDesignatedInitializers open class PrivateKey {
    public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
    public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
    public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class PublicKey {
    public static func addHeader(_ derKey: Foundation.Data) -> Foundation.Data
    public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
    public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
    public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class WFPEM {
  public enum SwError : Swift.Error {
    case parse(Swift.String)
    case badPassphrase
    case keyNotEncrypted
    public static var debugLevel: Swift.Int
  }
  @_hasMissingDesignatedInitializers open class PrivateKey {
    public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class PublicKey {
    public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class EncryptedPrivateKey {
    public enum EncMode {
      case aes128CBC, aes256CBC
      public static func == (a: PayU3DS2CoreKit.WFPEM.EncryptedPrivateKey.EncMode, b: PayU3DS2CoreKit.WFPEM.EncryptedPrivateKey.EncMode) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static func toDER(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Foundation.Data
    public static func toPEM(_ derKey: Foundation.Data, passphrase: Swift.String, mode: PayU3DS2CoreKit.WFPEM.EncryptedPrivateKey.EncMode) -> Swift.String
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class WFCC {
  public typealias CCCryptorStatus = Swift.Int32
  public enum CCError : PayU3DS2CoreKit.WFCC.CCCryptorStatus, Swift.Error {
    case paramError
    case bufferTooSmall
    case memoryFailure
    case alignmentError
    case decodeError
    case unimplemented
    case overflow
    case rngFailure
    case unspecifiedError
    case callSequenceError
    case keySizeError
    case invalidKey
    public static var debugLevel: Swift.Int
    public init?(rawValue: PayU3DS2CoreKit.WFCC.CCCryptorStatus)
    public typealias RawValue = PayU3DS2CoreKit.WFCC.CCCryptorStatus
    public var rawValue: PayU3DS2CoreKit.WFCC.CCCryptorStatus {
      get
    }
  }
  public static func generateRandom(_ size: Swift.Int) -> Foundation.Data
  public typealias CCDigestAlgorithm = Swift.UInt32
  public enum DigestAlgorithm : PayU3DS2CoreKit.WFCC.CCDigestAlgorithm {
    case none
    case md5
    case rmd128, rmd160, rmd256, rmd320
    case sha1
    case sha224, sha256, sha384, sha512
    public init?(rawValue: PayU3DS2CoreKit.WFCC.CCDigestAlgorithm)
    public typealias RawValue = PayU3DS2CoreKit.WFCC.CCDigestAlgorithm
    public var rawValue: PayU3DS2CoreKit.WFCC.CCDigestAlgorithm {
      get
    }
  }
  public static func digest(_ data: Foundation.Data, alg: PayU3DS2CoreKit.WFCC.DigestAlgorithm) -> Foundation.Data
  public typealias CCHmacAlgorithm = Swift.UInt32
  public enum HMACAlg : PayU3DS2CoreKit.WFCC.CCHmacAlgorithm {
    case sha1, md5, sha256, sha384, sha512, sha224
    public init?(rawValue: PayU3DS2CoreKit.WFCC.CCHmacAlgorithm)
    public typealias RawValue = PayU3DS2CoreKit.WFCC.CCHmacAlgorithm
    public var rawValue: PayU3DS2CoreKit.WFCC.CCHmacAlgorithm {
      get
    }
  }
  public static func HMAC(_ data: Foundation.Data, alg: PayU3DS2CoreKit.WFCC.HMACAlg, key: Foundation.Data) -> Foundation.Data
  public typealias CCOperation = Swift.UInt32
  public enum OpMode : PayU3DS2CoreKit.WFCC.CCOperation {
    case encrypt, decrypt
    public init?(rawValue: PayU3DS2CoreKit.WFCC.CCOperation)
    public typealias RawValue = PayU3DS2CoreKit.WFCC.CCOperation
    public var rawValue: PayU3DS2CoreKit.WFCC.CCOperation {
      get
    }
  }
  public typealias CCMode = Swift.UInt32
  public enum BlockMode : PayU3DS2CoreKit.WFCC.CCMode {
    case ecb, cbc, cfb, ctr, f8, lrw, ofb, xts, rc4, cfb8
    public init?(rawValue: PayU3DS2CoreKit.WFCC.CCMode)
    public typealias RawValue = PayU3DS2CoreKit.WFCC.CCMode
    public var rawValue: PayU3DS2CoreKit.WFCC.CCMode {
      get
    }
  }
  public enum AuthBlockMode : PayU3DS2CoreKit.WFCC.CCMode {
    case gcm, ccm
    public init?(rawValue: PayU3DS2CoreKit.WFCC.CCMode)
    public typealias RawValue = PayU3DS2CoreKit.WFCC.CCMode
    public var rawValue: PayU3DS2CoreKit.WFCC.CCMode {
      get
    }
  }
  public typealias CCAlgorithm = Swift.UInt32
  public enum Algorithm : PayU3DS2CoreKit.WFCC.CCAlgorithm {
    case aes, des, threeDES, cast, rc4, rc2, blowfish
    public init?(rawValue: PayU3DS2CoreKit.WFCC.CCAlgorithm)
    public typealias RawValue = PayU3DS2CoreKit.WFCC.CCAlgorithm
    public var rawValue: PayU3DS2CoreKit.WFCC.CCAlgorithm {
      get
    }
  }
  public typealias CCPadding = Swift.UInt32
  public enum Padding : PayU3DS2CoreKit.WFCC.CCPadding {
    case noPadding, pkcs7Padding
    public init?(rawValue: PayU3DS2CoreKit.WFCC.CCPadding)
    public typealias RawValue = PayU3DS2CoreKit.WFCC.CCPadding
    public var rawValue: PayU3DS2CoreKit.WFCC.CCPadding {
      get
    }
  }
  public static func crypt(_ opMode: PayU3DS2CoreKit.WFCC.OpMode, blockMode: PayU3DS2CoreKit.WFCC.BlockMode, algorithm: PayU3DS2CoreKit.WFCC.Algorithm, padding: PayU3DS2CoreKit.WFCC.Padding, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data) throws -> Foundation.Data
  public static func cryptAuth(_ opMode: PayU3DS2CoreKit.WFCC.OpMode, blockMode: PayU3DS2CoreKit.WFCC.AuthBlockMode, algorithm: PayU3DS2CoreKit.WFCC.Algorithm, data: Foundation.Data, aData: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, tagLength: Swift.Int) throws -> Foundation.Data
  public static func digestAvailable() -> Swift.Bool
  public static func randomAvailable() -> Swift.Bool
  public static func hmacAvailable() -> Swift.Bool
  public static func cryptorAvailable() -> Swift.Bool
  public static func available() -> Swift.Bool
  @_hasMissingDesignatedInitializers open class GCM {
    public static func crypt(_ opMode: PayU3DS2CoreKit.WFCC.OpMode, algorithm: PayU3DS2CoreKit.WFCC.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class CCM {
    public static func crypt(_ opMode: PayU3DS2CoreKit.WFCC.OpMode, algorithm: PayU3DS2CoreKit.WFCC.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class RSA {
    public typealias CCAsymmetricPadding = Swift.UInt32
    public enum AsymmetricPadding : PayU3DS2CoreKit.WFCC.RSA.CCAsymmetricPadding {
      case pkcs1
      case oaep
      public init?(rawValue: PayU3DS2CoreKit.WFCC.RSA.CCAsymmetricPadding)
      public typealias RawValue = PayU3DS2CoreKit.WFCC.RSA.CCAsymmetricPadding
      public var rawValue: PayU3DS2CoreKit.WFCC.RSA.CCAsymmetricPadding {
        get
      }
    }
    public enum AsymmetricSAPadding : Swift.UInt32 {
      case pkcs15
      case pss
      public init?(rawValue: Swift.UInt32)
      public typealias RawValue = Swift.UInt32
      public var rawValue: Swift.UInt32 {
        get
      }
    }
    public static func generateKeyPair(_ keySize: Swift.Int = 4096) throws -> (Foundation.Data, Foundation.Data)
    public static func getPublicKeyFromPrivateKey(_ derKey: Foundation.Data) throws -> Foundation.Data
    public static func encrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: PayU3DS2CoreKit.WFCC.RSA.AsymmetricPadding, digest: PayU3DS2CoreKit.WFCC.DigestAlgorithm) throws -> Foundation.Data
    public static func decrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: PayU3DS2CoreKit.WFCC.RSA.AsymmetricPadding, digest: PayU3DS2CoreKit.WFCC.DigestAlgorithm) throws -> (Foundation.Data, Swift.Int)
    public static func sign(_ message: Foundation.Data, derKey: Foundation.Data, padding: PayU3DS2CoreKit.WFCC.RSA.AsymmetricSAPadding, digest: PayU3DS2CoreKit.WFCC.DigestAlgorithm, saltLen: Swift.Int) throws -> Foundation.Data
    public static func verify(_ message: Foundation.Data, derKey: Foundation.Data, padding: PayU3DS2CoreKit.WFCC.RSA.AsymmetricSAPadding, digest: PayU3DS2CoreKit.WFCC.DigestAlgorithm, saltLen: Swift.Int, signedData: Foundation.Data) throws -> Swift.Bool
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class DH {
    public enum DHParam {
      case rfc3526Group5
      case rfc2409Group2
      public static func == (a: PayU3DS2CoreKit.WFCC.DH.DHParam, b: PayU3DS2CoreKit.WFCC.DH.DHParam) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    open class DH {
      public init(dhParam: PayU3DS2CoreKit.WFCC.DH.DHParam) throws
      open func generateKey() throws -> Foundation.Data
      open func computeKey(_ peerKey: Foundation.Data) throws -> Foundation.Data
      @objc deinit
    }
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class EC {
    public static func generateKeyPair(_ keySize: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
    public static func getPublicKeyFromPrivateKey(_ privateKey: Foundation.Data) throws -> Foundation.Data
    public static func signHash(_ privateKey: Foundation.Data, hash: Foundation.Data) throws -> Foundation.Data
    public static func verifyHash(_ publicKey: Foundation.Data, hash: Foundation.Data, signedData: Foundation.Data) throws -> Swift.Bool
    public static func computeSharedSecret(_ privateKey: Foundation.Data, publicKey: Foundation.Data) throws -> Foundation.Data
    public struct KeyComponents {
      public init(_ keySize: Swift.Int, _ x: Foundation.Data, _ y: Foundation.Data, _ d: Foundation.Data)
      public var keySize: Swift.Int
      public var x: Foundation.Data
      public var y: Foundation.Data
      public var d: Foundation.Data
    }
    public static func getPublicKeyComponents(_ keyData: Foundation.Data) throws -> PayU3DS2CoreKit.WFCC.EC.KeyComponents
    public static func getPrivateKeyComponents(_ keyData: Foundation.Data) throws -> PayU3DS2CoreKit.WFCC.EC.KeyComponents
    public static func createFromData(_ keySize: Darwin.size_t, _ x: Foundation.Data, _ y: Foundation.Data) throws -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class CRC {
    public typealias CNcrc = Swift.UInt32
    public enum Mode : PayU3DS2CoreKit.WFCC.CRC.CNcrc {
      case crc8, crc8ICODE, crc8ITU, crc8ROHC, crc8WCDMA, crc16, crc16CCITTTrue, crc16CCITTFalse, crc16USB, crc16XMODEM, crc16DECTR, crc16DECTX, crc16ICODE, crc16VERIFONE, crc16A, crc16B, crc16Fletcher, crc32Adler, crc32, crc32CASTAGNOLI, crc32BZIP2, crc32MPEG2, crc32POSIX, crc32XFER, crc64ECMA182
      public init?(rawValue: PayU3DS2CoreKit.WFCC.CRC.CNcrc)
      public typealias RawValue = PayU3DS2CoreKit.WFCC.CRC.CNcrc
      public var rawValue: PayU3DS2CoreKit.WFCC.CRC.CNcrc {
        get
      }
    }
    public static func crc(_ input: Foundation.Data, mode: PayU3DS2CoreKit.WFCC.CRC.Mode) throws -> Swift.UInt64
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class CMAC {
    public static func AESCMAC(_ data: Foundation.Data, key: Foundation.Data) -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class KeyDerivation {
    public typealias CCPseudoRandomAlgorithm = Swift.UInt32
    public enum PRFAlg : PayU3DS2CoreKit.WFCC.KeyDerivation.CCPseudoRandomAlgorithm {
      case sha1, sha224, sha256, sha384, sha512
      public init?(rawValue: PayU3DS2CoreKit.WFCC.KeyDerivation.CCPseudoRandomAlgorithm)
      public typealias RawValue = PayU3DS2CoreKit.WFCC.KeyDerivation.CCPseudoRandomAlgorithm
      public var rawValue: PayU3DS2CoreKit.WFCC.KeyDerivation.CCPseudoRandomAlgorithm {
        get
      }
    }
    public static func PBKDF2(_ password: Swift.String, salt: Foundation.Data, prf: PayU3DS2CoreKit.WFCC.KeyDerivation.PRFAlg, rounds: Swift.UInt32) throws -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class KeyWrap {
    public static let rfc3394IV: Foundation.Data
    public static func SymmetricKeyWrap(_ iv: Foundation.Data, kek: Foundation.Data, rawKey: Foundation.Data) throws -> Foundation.Data
    public static func SymmetricKeyUnwrap(_ iv: Foundation.Data, kek: Foundation.Data, wrappedKey: Foundation.Data) throws -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @objc deinit
}
extension Foundation.Data {
  public func hexadecimalString() -> Swift.String
  public func arrayOfBytes() -> [Swift.UInt8]
}
extension Swift.String {
  public func dataFromHexadecimalString() -> Foundation.Data?
}
public enum DeviceRenderInterface : Swift.String, Swift.Codable {
  case native
  case html
  case both
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum DeviceRenderUiType : Swift.String, Swift.Codable {
  case text
  case singleSelect
  case multiSelect
  case oob
  case html
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class DeviceRenderOptions : Swift.Codable {
  public init(interface: PayU3DS2CoreKit.DeviceRenderInterface = .both, uiType: [PayU3DS2CoreKit.DeviceRenderUiType] = [.html, .text, .singleSelect, .multiSelect, .oob])
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
extension Foundation.Data {
  public init?(base64URLEncodedString: Swift.String)
  public func base64URLEncodedString() -> Swift.String
  public func toArrayUInt8() -> [Swift.UInt8]
  public func jsonDataToDic() -> [Swift.String : Any]?
}
extension UIKit.UIApplication {
  @_Concurrency.MainActor(unsafe) public class func topViewController(base: UIKit.UIViewController?) -> UIKit.UIViewController?
}
public protocol WFCipherModeWorker {
  var cipherOperation: PayU3DS2CoreKit.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol WFBlockModeWorker : PayU3DS2CoreKit.WFCipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol WFCounterModeWorker : PayU3DS2CoreKit.WFCipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol WFSeekableModeWorker : PayU3DS2CoreKit.WFCipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol WFStreamModeWorker : PayU3DS2CoreKit.WFCipherModeWorker {
}
public protocol WFFinalizingEncryptModeWorker : PayU3DS2CoreKit.WFCipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol WFFinalizingDecryptModeWorker : PayU3DS2CoreKit.WFCipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
@objc @_hasMissingDesignatedInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class PayULogoView : UIKit.UIView, QuartzCore.CAAnimationDelegate {
  @objc deinit
}
extension PayU3DS2CoreKit.PayULogoView {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func animationDidStop(_ anim: QuartzCore.CAAnimation, finished flag: Swift.Bool)
}
public protocol WFAuthenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.Array where Element == Swift.UInt8 {
  public func wftoBase64(options: Foundation.Data.Base64EncodingOptions = []) -> Swift.String
  public init(base64String: Swift.String, options: Foundation.Data.Base64DecodingOptions = .ignoreUnknownCharacters)
}
final public class WFChaCha20 {
  public enum WFError : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: PayU3DS2CoreKit.WFChaCha20.WFError, b: PayU3DS2CoreKit.WFChaCha20.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension PayU3DS2CoreKit.WFChaCha20 : PayU3DS2CoreKit.WFCipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension PayU3DS2CoreKit.WFChaCha20 {
  public struct WFChaChaEncryptor : PayU3DS2CoreKit.WFCryptor, PayU3DS2CoreKit.WFUpdatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension PayU3DS2CoreKit.WFChaCha20 {
  public struct WFChaChaDecryptor : PayU3DS2CoreKit.WFCryptor, PayU3DS2CoreKit.WFUpdatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension PayU3DS2CoreKit.WFChaCha20 : PayU3DS2CoreKit.WFCryptors {
  final public func makeEncryptor() -> PayU3DS2CoreKit.WFCryptor & PayU3DS2CoreKit.WFUpdatable
  final public func makeDecryptor() -> PayU3DS2CoreKit.WFCryptor & PayU3DS2CoreKit.WFUpdatable
}
public enum WFDevice {
  case iPodTouch5
  case iPodTouch6
  case iPodTouch7
  case iPhone4
  case iPhone4s
  case iPhone5
  case iPhone5c
  case iPhone5s
  case iPhone6
  case iPhone6Plus
  case iPhone6s
  case iPhone6sPlus
  case iPhone7
  case iPhone7Plus
  case iPhoneSE
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case iPhoneXS
  case iPhoneXSMax
  case iPhoneXR
  case iPhone11
  case iPhone11Pro
  case iPhone11ProMax
  case iPad2
  case iPad3
  case iPad4
  case iPadAir
  case iPadAir2
  case iPad5
  case iPad6
  case iPadAir3
  case iPad7
  case iPadMini
  case iPadMini2
  case iPadMini3
  case iPadMini4
  case iPadMini5
  case iPadPro9Inch
  case iPadPro12Inch
  case iPadPro12Inch2
  case iPadPro10Inch
  case iPadPro11Inch
  case iPadPro12Inch3
  case homePod
  indirect case simulator(PayU3DS2CoreKit.WFDevice)
  case unknown(Swift.String)
  public static var current: PayU3DS2CoreKit.WFDevice {
    get
  }
  public static var identifier: Swift.String
  public static func mapToDevice(identifier: Swift.String) -> PayU3DS2CoreKit.WFDevice
  public static func realDevice(from device: PayU3DS2CoreKit.WFDevice) -> PayU3DS2CoreKit.WFDevice
  public var diagonal: Swift.Double {
    get
  }
  public var screenRatio: (width: Swift.Double, height: Swift.Double) {
    get
  }
  public static var allPods: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allPhones: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allPads: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allXSeriesDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allPlusSizedDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allProDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allMiniDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allSimulatorPods: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allSimulatorPhones: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allSimulatorPads: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allSimulatorMiniDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allSimulatorXSeriesDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allSimulatorPlusSizedDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allSimulatorProDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public var isPod: Swift.Bool {
    get
  }
  public var isPhone: Swift.Bool {
    get
  }
  public var isPad: Swift.Bool {
    get
  }
  public var isSimulator: Swift.Bool {
    get
  }
  public var realDevice: PayU3DS2CoreKit.WFDevice {
    get
  }
  public var isZoomed: Swift.Bool? {
    get
  }
  public static var allTouchIDCapableDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allFaceIDCapableDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public var isTouchIDCapable: Swift.Bool {
    get
  }
  public var isFaceIDCapable: Swift.Bool {
    get
  }
  public var hasBiometricSensor: Swift.Bool {
    get
  }
  public static var allDevicesWithSensorHousing: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public var hasSensorHousing: Swift.Bool {
    get
  }
  public static var allDevicesWithRoundedDisplayCorners: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public var hasRoundedDisplayCorners: Swift.Bool {
    get
  }
  public static var allDevicesWith3dTouchSupport: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public var has3dTouchSupport: Swift.Bool {
    get
  }
  public static var allRealDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allSimulators: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public func isOneOf(_ devices: [PayU3DS2CoreKit.WFDevice]) -> Swift.Bool
  public var name: Swift.String? {
    get
  }
  public var systemName: Swift.String? {
    get
  }
  public var systemVersion: Swift.String? {
    get
  }
  public var model: Swift.String? {
    get
  }
  public var localizedModel: Swift.String? {
    get
  }
  public var ppi: Swift.Int? {
    get
  }
  public var isGuidedAccessSessionActive: Swift.Bool {
    get
  }
  public var screenBrightness: Swift.Int {
    get
  }
}
extension PayU3DS2CoreKit.WFDevice : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension PayU3DS2CoreKit.WFDevice : Swift.Equatable {
  public static func == (lhs: PayU3DS2CoreKit.WFDevice, rhs: PayU3DS2CoreKit.WFDevice) -> Swift.Bool
}
@available(iOS 8.0, watchOS 4.0, *)
extension PayU3DS2CoreKit.WFDevice {
  public enum BatteryState : Swift.CustomStringConvertible, Swift.Equatable {
    case full
    case charging(Swift.Int)
    case unplugged(Swift.Int)
    public var lowPowerMode: Swift.Bool {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  public var batteryState: PayU3DS2CoreKit.WFDevice.BatteryState? {
    get
  }
  public var batteryLevel: Swift.Int? {
    get
  }
}
@available(iOS 8.0, watchOS 4.0, *)
extension PayU3DS2CoreKit.WFDevice.BatteryState : Swift.Comparable {
  public static func == (lhs: PayU3DS2CoreKit.WFDevice.BatteryState, rhs: PayU3DS2CoreKit.WFDevice.BatteryState) -> Swift.Bool
  public static func < (lhs: PayU3DS2CoreKit.WFDevice.BatteryState, rhs: PayU3DS2CoreKit.WFDevice.BatteryState) -> Swift.Bool
}
extension PayU3DS2CoreKit.WFDevice {
  public enum Orientation {
    case landscape
    case portrait
    public static func == (a: PayU3DS2CoreKit.WFDevice.Orientation, b: PayU3DS2CoreKit.WFDevice.Orientation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var orientation: PayU3DS2CoreKit.WFDevice.Orientation {
    get
  }
}
extension PayU3DS2CoreKit.WFDevice {
  public static var volumeTotalCapacity: Swift.Int? {
    get
  }
  public static var volumeAvailableCapacity: Swift.Int? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumeAvailableCapacityForImportantUsage: Swift.Int64? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumeAvailableCapacityForOpportunisticUsage: Swift.Int64? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumes: [Foundation.URLResourceKey : Swift.Int64]? {
    get
  }
}
extension PayU3DS2CoreKit.WFDevice {
  public struct ApplePencilSupport : Swift.OptionSet {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let firstGeneration: PayU3DS2CoreKit.WFDevice.ApplePencilSupport
    public static let secondGeneration: PayU3DS2CoreKit.WFDevice.ApplePencilSupport
    public typealias ArrayLiteralElement = PayU3DS2CoreKit.WFDevice.ApplePencilSupport
    public typealias Element = PayU3DS2CoreKit.WFDevice.ApplePencilSupport
    public typealias RawValue = Swift.UInt
  }
  public static var allApplePencilCapableDevices: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public var applePencilSupport: PayU3DS2CoreKit.WFDevice.ApplePencilSupport {
    get
  }
}
extension PayU3DS2CoreKit.WFDevice {
  public enum CameraTypes {
    case normal
    case telephoto
    case ultraWide
    public static func == (a: PayU3DS2CoreKit.WFDevice.CameraTypes, b: PayU3DS2CoreKit.WFDevice.CameraTypes) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var cameras: [PayU3DS2CoreKit.WFDevice.CameraTypes] {
    get
  }
  public static var allDevicesWithCamera: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allDevicesWithNormalCamera: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allDevicesWithTelephotoCamera: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public static var allDevicesWithUltraWideCamera: [PayU3DS2CoreKit.WFDevice] {
    get
  }
  public var hasCamera: Swift.Bool {
    get
  }
  public var hasNormalCamera: Swift.Bool {
    get
  }
  public var hasTelephotoCamera: Swift.Bool {
    get
  }
  public var hasUltraWideCamera: Swift.Bool {
    get
  }
}
@_hasMissingDesignatedInitializers public class LoadingOverlay {
  public enum LoadingType {
    case progress
    case customProgress(Swift.String, UIKit.UIColor)
    case logo(logoImageName: Swift.String)
  }
  public func show(view: UIKit.UIView? = nil, loadingType: PayU3DS2CoreKit.LoadingOverlay.LoadingType = .progress)
  public func hide()
  @objc deinit
}
extension PayU3DS2CoreKit.WFBlowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: PayU3DS2CoreKit.WFPadding = .pkcs7) throws
}
public struct WFCTR {
  public enum WFError : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PayU3DS2CoreKit.WFCTR.WFError, b: PayU3DS2CoreKit.WFCTR.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PayU3DS2CoreKit.WFBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
}
final public class WFAES {
  public enum WFError : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: PayU3DS2CoreKit.WFAES.WFError, b: PayU3DS2CoreKit.WFAES.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum WFVariant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: PayU3DS2CoreKit.WFAES.WFVariant
  @usableFromInline
  final internal let blockMode: PayU3DS2CoreKit.WFBlockMode
  @usableFromInline
  final internal let padding: PayU3DS2CoreKit.WFPadding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: PayU3DS2CoreKit.WFBlockMode, padding: PayU3DS2CoreKit.WFPadding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != WFAES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = WFAES.T0[Int(t[0] & 0xff)]
      let lb01 = WFAES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = WFAES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = WFAES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = WFAES.T0[Int(t[1] & 0xff)]
      let lb11 = WFAES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = WFAES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = WFAES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = WFAES.T0[Int(t[2] & 0xff)]
      let lb21 = WFAES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = WFAES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = WFAES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = WFAES.T0[Int(t[3] & 0xff)]
      let lb31 = WFAES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = WFAES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = WFAES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension PayU3DS2CoreKit.WFAES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension PayU3DS2CoreKit.WFAES : PayU3DS2CoreKit.WFCipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? WFAES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % WFAES.blockSize != 0) {
      throw WFError.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % WFAES.blockSize != 0) {
      throw WFError.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: WFAES.blockSize)
    if chunks.isEmpty {
      throw WFError.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
public protocol WFUpdatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension PayU3DS2CoreKit.WFUpdatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
@objc public class LabelCustomization : PayU3DS2CoreKit.Customization {
  @objc public var headingTxtColor: Swift.String? {
    get
  }
  @objc public var headingTxtFontName: Swift.String {
    get
  }
  @objc public var headingTxtFontSize: Swift.Int {
    get
  }
  @objc public init(headingTxtFontName: Swift.String = DefaultConstants.fontName, headingTxtColor: Swift.String? = nil, headingTxtFontSize: Swift.Int = Int(UIFont.systemFontSize))
  @objc public func setHeadingTextFontName(_ fontName: Swift.String)
  @objc public func setHeadingTextColor(_ hexColorCode: Swift.String)
  @objc public func setHeadingTextFontSize(_ fontSize: Swift.Int)
  @objc public func getHeadingTextFontName() -> Swift.String
  @objc public func getHeadingTextColor() -> Swift.String?
  @objc public func getHeadingTextFontSize() -> Swift.Int
  @objc deinit
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
@objc public class TextBoxCustomization : PayU3DS2CoreKit.Customization {
  @objc public init(borderWidth: Swift.Int = 1, cornerRadius: Swift.Int = 5, borderColor: Swift.String? = nil)
  @objc public func setBorderWidth(_ borderWidth: Swift.Int)
  @objc public func getBorderWidth() -> Swift.Int
  @objc public func setBorderColor(_ hexColorCode: Swift.String)
  @objc public func getBorderColor() -> Swift.String?
  @objc public func setCornerRadius(_ cornerRadius: Swift.Int)
  @objc public func getCornerRadius() -> Swift.Int
  @objc public func setPlaceHolderText(_ placeHolder: Swift.String)
  @objc public func getPlaceHolderText() -> Swift.String?
  @objc public func setSecureTextField(_ isSecureTextField: Swift.Bool)
  @objc public func getSecureTextField() -> Swift.Bool
  @objc deinit
}
public protocol WFCryptors : AnyObject {
  func makeEncryptor() throws -> PayU3DS2CoreKit.WFCryptor & PayU3DS2CoreKit.WFUpdatable
  func makeDecryptor() throws -> PayU3DS2CoreKit.WFCryptor & PayU3DS2CoreKit.WFUpdatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension PayU3DS2CoreKit.WFCryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) public class PayULoaderView : PayU3DS2CoreKit.PayUBaseView {
  @objc @_Concurrency.MainActor(unsafe) public func updateDescriptionMessage(_ message: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc public class Customization : ObjectiveC.NSObject {
  public init(txtFontName: Swift.String = DefaultConstants.fontName, txtColor: Swift.String? = nil, txtFontSize: Swift.Int = Int(UIFont.systemFontSize))
  @objc public func setTextFontName(_ fontName: Swift.String)
  @objc public func setTextColor(_ hexColorCode: Swift.String)
  @objc public func setTextFontSize(_ fontSize: Swift.Int)
  @objc public func getTextFontName() -> Swift.String
  @objc public func getTextColor() -> Swift.String?
  @objc public func getTextFontSize() -> Swift.Int
  @objc deinit
}
@usableFromInline
final internal class WFStreamEncryptor : PayU3DS2CoreKit.WFCryptor, PayU3DS2CoreKit.WFUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: PayU3DS2CoreKit.WFCipherModeWorker
  @usableFromInline
  final internal let padding: PayU3DS2CoreKit.WFPadding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PayU3DS2CoreKit.WFPadding, _ worker: PayU3DS2CoreKit.WFCipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? WFFinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
@_inheritsConvenienceInitializers @objc public class SDKAlreadyInitializedException : PayU3DS2CoreKit.RuntimeException {
  @objc override public init(message: Swift.String, cause: Swift.String?)
  @objc deinit
}
final public class WFSHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension PayU3DS2CoreKit.WFSHA1 : PayU3DS2CoreKit.WFUpdatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: WFSHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: WFSHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= WFSHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: WFSHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = WFSHA1.hashInitialValue
    }

    return result
  }
}
extension PayU3DS2CoreKit.WFPKCS5 {
  public struct WFPBKDF1 {
    public enum WFError : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFError, b: PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFError) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum WFVariant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFVariant, b: PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFVariant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFVariant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFVariant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
    public func callAsFunction() -> Swift.Array<Swift.UInt8>
  }
}
public enum WFBit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension PayU3DS2CoreKit.WFBit {
  @inlinable internal func inverted() -> PayU3DS2CoreKit.WFBit {
    self == .zero ? .one : .zero
  }
}
final public class WFSHA2 {
  @usableFromInline
  final internal let variant: PayU3DS2CoreKit.WFSHA2.WFVariant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum WFVariant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: PayU3DS2CoreKit.WFSHA2.WFVariant.RawValue {
      get
    }
    public init?(rawValue: PayU3DS2CoreKit.WFSHA2.WFVariant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: PayU3DS2CoreKit.WFSHA2.WFVariant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension PayU3DS2CoreKit.WFSHA2 : PayU3DS2CoreKit.WFUpdatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
extension Swift.String {
  public func wfdecryptBase64ToString(cipher: PayU3DS2CoreKit.WFCipher) throws -> Swift.String
  public func wfdecryptBase64(cipher: PayU3DS2CoreKit.WFCipher) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
  @inlinable internal subscript(safe index: Swift.Array<Element>.Index) -> Element? {
    get {
    return indices.contains(index) ? self[index] : nil
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hexString: Swift.String)
  public func wftoHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func wfchunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func wfmd5() -> [Element]
  public func wfsha1() -> [Element]
  public func wfsha224() -> [Element]
  public func sha256() -> [Element]
  public func wfsha384() -> [Element]
  public func wfsha512() -> [Element]
  public func wfsha2(_ variant: PayU3DS2CoreKit.WFSHA2.WFVariant) -> [Element]
  public func wfsha3(_ variant: PayU3DS2CoreKit.WFSHA3.WFVariant) -> [Element]
  public func wfcrc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func wfcrc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func wfcrc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func wfencrypt(cipher: PayU3DS2CoreKit.WFCipher) throws -> [Element]
  public func wfdecrypt(cipher: PayU3DS2CoreKit.WFCipher) throws -> [Element]
  public func wfauthenticate<A>(with authenticator: A) throws -> [Element] where A : PayU3DS2CoreKit.WFAuthenticator
}
final public class WFOCB : PayU3DS2CoreKit.WFBlockMode {
  public enum WFMode {
    case combined
    case detached
    public static func == (a: PayU3DS2CoreKit.WFOCB.WFMode, b: PayU3DS2CoreKit.WFOCB.WFMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: PayU3DS2CoreKit.WFBlockModeOption
  public enum WFError : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: PayU3DS2CoreKit.WFOCB.WFError, b: PayU3DS2CoreKit.WFOCB.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: PayU3DS2CoreKit.WFOCB.WFMode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: PayU3DS2CoreKit.WFOCB.WFMode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
  @objc deinit
}
public protocol WF_UInt8Type {
}
extension Swift.UInt8 : PayU3DS2CoreKit.WF_UInt8Type {
}
extension Swift.UInt8 {
  public func wfbits() -> [PayU3DS2CoreKit.WFBit]
  public func wfbits() -> Swift.String
}
public struct WFPCBC : PayU3DS2CoreKit.WFBlockMode {
  public enum WFError : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PayU3DS2CoreKit.WFPCBC.WFError, b: PayU3DS2CoreKit.WFPCBC.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PayU3DS2CoreKit.WFBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
}
public enum KeyType : Swift.String {
  case rsa
  case ec
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc public enum ACSUITypeInt : Swift.Int {
  case error = -1
  case unknown = 0
  case text
  case singleSelect
  case multiSelect
  case oob
  case html
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ACSUIType : Swift.String, Swift.Codable {
  case error
  case unknown
  case text
  case singleSelect
  case multiSelect
  case oob
  case html
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension PayU3DS2CoreKit.ACSUIType {
  public init(from decoder: Swift.Decoder) throws
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits ≡ 448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
public protocol WFPaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum WFPadding : PayU3DS2CoreKit.WFPaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, eme_pkcs1v15, emsa_pkcs1v15, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: PayU3DS2CoreKit.WFPadding, b: PayU3DS2CoreKit.WFPadding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
public enum WFCipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: PayU3DS2CoreKit.WFCipherError, b: PayU3DS2CoreKit.WFCipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol WFCipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension PayU3DS2CoreKit.WFCipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class WFHMAC : PayU3DS2CoreKit.WFAuthenticator {
  public enum WFError : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: PayU3DS2CoreKit.WFHMAC.WFError, b: PayU3DS2CoreKit.WFHMAC.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum WFVariant {
    case md5
    case sha1
    case sha2(PayU3DS2CoreKit.WFSHA2.WFVariant)
    case sha3(PayU3DS2CoreKit.WFSHA3.WFVariant)
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha256, sha384, sha512
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: PayU3DS2CoreKit.WFHMAC.WFVariant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
@usableFromInline
final internal class WFStreamDecryptor : PayU3DS2CoreKit.WFCryptor, PayU3DS2CoreKit.WFUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: PayU3DS2CoreKit.WFCipherModeWorker
  @usableFromInline
  final internal let padding: PayU3DS2CoreKit.WFPadding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PayU3DS2CoreKit.WFPadding, _ worker: PayU3DS2CoreKit.WFCipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? WFFinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? WFFinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? WFFinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? WFSeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
@objc public class ButtonCustomization : PayU3DS2CoreKit.Customization {
  @objc public var backgroundColor: Swift.String?
  @objc public var cornerRadius: Swift.Int
  public init(backgroundColor: Swift.String?, cornerRadius: Swift.Int = 0)
  public func setBackgroundColor(_ hexColorCode: Swift.String)
  public func setCornerRadius(_ cornerRadius: Swift.Int)
  public func getBackgroundColor() -> Swift.String?
  public func getCornerRadius() -> Swift.Int
  @objc deinit
}
extension PayU3DS2CoreKit.ButtonCustomization {
  public enum ButtonTextTransformType : Swift.String, Swift.Codable {
    case lowercase
    case uppercase
    case `default`
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public func setTextTransform(textTransform: PayU3DS2CoreKit.ButtonCustomization.ButtonTextTransformType)
  public func getBtnTextTransform(title: Swift.String) -> Swift.String
}
public enum WFPKCS5 {
}
extension Foundation.Data {
  public func wfchecksum() -> Swift.UInt16
  public func wfmd5() -> Foundation.Data
  public func wfsha1() -> Foundation.Data
  public func wfsha224() -> Foundation.Data
  public func wfsha256() -> Foundation.Data
  public func wfsha384() -> Foundation.Data
  public func wfsha512() -> Foundation.Data
  public func wfsha3(_ variant: PayU3DS2CoreKit.WFSHA3.WFVariant) -> Foundation.Data
  public func wfcrc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func wfcrc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func wfcrc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func wfencrypt(cipher: PayU3DS2CoreKit.WFCipher) throws -> Foundation.Data
  public func wfdecrypt(cipher: PayU3DS2CoreKit.WFCipher) throws -> Foundation.Data
  public func wfauthenticate(with authenticator: PayU3DS2CoreKit.WFAuthenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hexString: Swift.String)
  public var wfbytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func wftoHexString() -> Swift.String
}
extension Swift.String {
  @inlinable public var wfbytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.wfbytes ?? Array(utf8)
  }
  }
  @inlinable public func wfmd5() -> Swift.String {
    self.wfbytes.wfmd5().wftoHexString()
  }
  @inlinable public func wfsha1() -> Swift.String {
    self.wfbytes.wfsha1().wftoHexString()
  }
  @inlinable public func wfsha224() -> Swift.String {
    self.wfbytes.wfsha224().wftoHexString()
  }
  @inlinable public func wfsha256() -> Swift.String {
    self.wfbytes.sha256().wftoHexString()
  }
  @inlinable public func wfsha384() -> Swift.String {
    self.wfbytes.wfsha384().wftoHexString()
  }
  @inlinable public func wfsha512() -> Swift.String {
    self.wfbytes.wfsha512().wftoHexString()
  }
  @inlinable public func wfsha3(_ variant: PayU3DS2CoreKit.WFSHA3.WFVariant) -> Swift.String {
    self.wfbytes.wfsha3(variant).wftoHexString()
  }
  @inlinable public func wfcrc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.wfbytes.wfcrc32(seed: seed, reflect: reflect).bytes().wftoHexString()
  }
  @inlinable public func wfcrc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.wfbytes.wfcrc32c(seed: seed, reflect: reflect).bytes().wftoHexString()
  }
  @inlinable public func wfcrc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.wfbytes.wfcrc16(seed: seed).bytes().wftoHexString()
  }
  @inlinable public func wfencrypt(cipher: PayU3DS2CoreKit.WFCipher) throws -> Swift.String {
    try self.wfbytes.wfencrypt(cipher: cipher).wftoHexString()
  }
  @inlinable public func wfencryptToBase64(cipher: PayU3DS2CoreKit.WFCipher) throws -> Swift.String {
    try self.wfbytes.wfencrypt(cipher: cipher).wftoBase64()
  }
  @inlinable public func wfauthenticate<A>(with authenticator: A) throws -> Swift.String where A : PayU3DS2CoreKit.WFAuthenticator {
    try self.wfbytes.wfauthenticate(with: authenticator).wftoHexString()
  }
}
final public class WFBlowfish {
  public enum WFError : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: PayU3DS2CoreKit.WFBlowfish.WFError, b: PayU3DS2CoreKit.WFBlowfish.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: PayU3DS2CoreKit.WFBlockMode = WFCBC(iv: Array<UInt8>(repeating: 0, count: WFBlowfish.blockSize)), padding: PayU3DS2CoreKit.WFPadding) throws
  @objc deinit
}
extension PayU3DS2CoreKit.WFBlowfish : PayU3DS2CoreKit.WFCipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public struct WFECB : PayU3DS2CoreKit.WFBlockMode {
  public let options: PayU3DS2CoreKit.WFBlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
}
@usableFromInline
internal struct WFBatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension PayU3DS2CoreKit.WFBatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: PayU3DS2CoreKit.WFBatchedCollectionIndex<Base>, rhs: PayU3DS2CoreKit.WFBatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: PayU3DS2CoreKit.WFBatchedCollectionIndex<Base>, rhs: PayU3DS2CoreKit.WFBatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct WFBatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = PayU3DS2CoreKit.WFBatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: PayU3DS2CoreKit.WFBatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: PayU3DS2CoreKit.WFBatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: PayU3DS2CoreKit.WFBatchedCollection<Base>.Index) -> PayU3DS2CoreKit.WFBatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: PayU3DS2CoreKit.WFBatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<PayU3DS2CoreKit.WFBatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<PayU3DS2CoreKit.WFBatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<PayU3DS2CoreKit.WFBatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> PayU3DS2CoreKit.WFBatchedCollection<Self> {
    WFBatchedCollection(base: self, size: size)
  }
}
public struct WFCFB : PayU3DS2CoreKit.WFBlockMode {
  public enum WFError : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PayU3DS2CoreKit.WFCFB.WFError, b: PayU3DS2CoreKit.WFCFB.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum WFSegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: PayU3DS2CoreKit.WFBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: PayU3DS2CoreKit.WFCFB.WFSegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
}
final public class WFSHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum WFVariant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: PayU3DS2CoreKit.WFSHA3.WFVariant, b: PayU3DS2CoreKit.WFSHA3.WFVariant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: PayU3DS2CoreKit.WFSHA3.WFVariant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension PayU3DS2CoreKit.WFSHA3 : PayU3DS2CoreKit.WFUpdatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
@objc public protocol LogHandler {
  @objc func logClevertapEvent(eventName: Swift.String)
  @objc func logKibanaEvent(eventJson: [Swift.String : Any])
}
public enum EventType {
  case Clevertap
  case Kibana
  public static func == (a: PayU3DS2CoreKit.EventType, b: PayU3DS2CoreKit.EventType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LogHelper {
  public static var shared: PayU3DS2CoreKit.LogHelper
  public func logEventFor(types: [PayU3DS2CoreKit.EventType] = [.Clevertap, .Kibana], key: Swift.String, value: Swift.String = "", className: Swift.String = "", txnId: Swift.String? = nil)
  @objc deinit
}
@objc public class AuthenticationRequestParameters : ObjectiveC.NSObject {
  @objc public var sdkTransactionID: Swift.String {
    get
  }
  @objc public var deviceData: Swift.String {
    get
  }
  public var sdkEphemeralPublicKey: PayU3DS2CoreKit.SdkEphemPubKey {
    get
  }
  @objc public var sdkAppID: Swift.String {
    get
  }
  @objc public var sdkReferenceNumber: Swift.String {
    get
  }
  @objc public var messageVersion: Swift.String {
    get
  }
  public init(sdkTransactionID: Swift.String, deviceData: Swift.String, sdkEphemeralPublicKey: PayU3DS2CoreKit.SdkEphemPubKey, sdkAppID: Swift.String, sdkReferenceNumber: Swift.String, messageVersion: Swift.String) throws
  public func getSDKEphemeralPublicKey() -> PayU3DS2CoreKit.SdkEphemPubKey
  @objc public func getDeviceData() -> Swift.String
  @objc public func getSDKTransactionID() -> Swift.String
  @objc public func getSDKReferenceNumber() -> Swift.String
  @objc public func getSDKAppID() -> Swift.String
  @objc deinit
}
public struct WFCBC : PayU3DS2CoreKit.WFBlockMode {
  public enum WFError : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PayU3DS2CoreKit.WFCBC.WFError, b: PayU3DS2CoreKit.WFCBC.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PayU3DS2CoreKit.WFBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock, encryptionOperation: @escaping PayU3DS2CoreKit.CipherOperationOnBlock) throws -> PayU3DS2CoreKit.WFCipherModeWorker
}
@objc public class UiCustomization : ObjectiveC.NSObject {
  @objc public var btnCustomizations: Swift.Dictionary<Swift.String, PayU3DS2CoreKit.ButtonCustomization>? {
    get
  }
  @objc public var tbrCustomization: PayU3DS2CoreKit.ToolbarCustomization? {
    get
  }
  @objc public var lblCustomization: PayU3DS2CoreKit.LabelCustomization? {
    get
  }
  @objc public var txtBxCustomization: PayU3DS2CoreKit.TextBoxCustomization? {
    get
  }
  @objc public var fontFamilyCustomization: PayU3DS2CoreKit.FontFamilyCustomization? {
    get
  }
  @objc public init(btnCustomizations: Swift.Dictionary<Swift.String, PayU3DS2CoreKit.ButtonCustomization>?, tbrCustomization: PayU3DS2CoreKit.ToolbarCustomization?, lblCustomization: PayU3DS2CoreKit.LabelCustomization?, txtBxCustomization: PayU3DS2CoreKit.TextBoxCustomization?, fontFamilyCustomization: PayU3DS2CoreKit.FontFamilyCustomization?)
  @objc open class func customizeUI() -> PayU3DS2CoreKit.UiCustomization
  @objc public enum ButtonTypeInt : Swift.Int {
    case VERIFY = 0
    case CONTINUE = 1
    case NEXT = 2
    case CANCEL = 3
    case RESEND = 4
    case SUBMIT = 5
    public static func buttonType(intType: PayU3DS2CoreKit.UiCustomization.ButtonTypeInt) -> PayU3DS2CoreKit.UiCustomization.ButtonType
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum ButtonType : Swift.String {
    case VERIFY
    case CONTINUE
    case NEXT
    case CANCEL
    case RESEND
    case SUBMIT
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc public func setButtonCustomization(_ buttonCustomization: PayU3DS2CoreKit.ButtonCustomization, _ buttonType: PayU3DS2CoreKit.UiCustomization.ButtonTypeInt) throws
  @objc public func setToolbarCustomization(_ toolbarCustomization: PayU3DS2CoreKit.ToolbarCustomization) throws
  @objc public func setLabelCustomization(_ labelCustomization: PayU3DS2CoreKit.LabelCustomization) throws
  @objc public func setTextBoxCustomization(_ textBoxCustomization: PayU3DS2CoreKit.TextBoxCustomization) throws
  @objc public func setFontFamilyCustomization(_ fontFamilyCustomization: PayU3DS2CoreKit.FontFamilyCustomization) throws
  @objc public func getButtonCustomization(_ buttonType: PayU3DS2CoreKit.UiCustomization.ButtonTypeInt) -> PayU3DS2CoreKit.ButtonCustomization?
  @objc public func getToolbarCustomization() -> PayU3DS2CoreKit.ToolbarCustomization?
  @objc public func getLabelCustomization() -> PayU3DS2CoreKit.LabelCustomization?
  @objc public func getTextBoxCustomization() -> PayU3DS2CoreKit.TextBoxCustomization?
  @objc public func getFontFamilyCustomization() -> PayU3DS2CoreKit.FontFamilyCustomization?
  @objc deinit
}
@objc public protocol ChallengeStatusReceiver {
  @objc func completed(_ e: PayU3DS2CoreKit.CompletionEvent!)
  @objc func cancelled()
  @objc func timedout()
  @objc func protocolError(_ e: PayU3DS2CoreKit.ProtocolErrorEvent!)
  @objc func runtimeError(_ e: PayU3DS2CoreKit.RuntimeErrorEvent!)
}
public class WFCMAC : PayU3DS2CoreKit.WFAuthenticator {
  public enum WFError : Swift.Error {
    case wrongKeyLength
    public static func == (a: PayU3DS2CoreKit.WFCMAC.WFError, b: PayU3DS2CoreKit.WFCMAC.WFError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: PayU3DS2CoreKit.WFCipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public protocol WFCryptor {
  mutating func seek(to: Swift.Int) throws
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (PayU3DS2CoreKit.Reachability) -> ()
  public typealias NetworkUnreachable = (PayU3DS2CoreKit.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: PayU3DS2CoreKit.Reachability.NetworkStatus, b: PayU3DS2CoreKit.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: PayU3DS2CoreKit.Reachability.Connection
    public static func == (a: PayU3DS2CoreKit.Reachability.Connection, b: PayU3DS2CoreKit.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: PayU3DS2CoreKit.Reachability.NetworkReachable?
  public var whenUnreachable: PayU3DS2CoreKit.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: PayU3DS2CoreKit.Reachability.Connection {
    get
  }
  public var connection: PayU3DS2CoreKit.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension PayU3DS2CoreKit.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct WFBlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: PayU3DS2CoreKit.WFBlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: PayU3DS2CoreKit.WFBlockModeOption
  @usableFromInline
  internal static let paddingRequired: PayU3DS2CoreKit.WFBlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: PayU3DS2CoreKit.WFBlockModeOption
  public typealias ArrayLiteralElement = PayU3DS2CoreKit.WFBlockModeOption
  public typealias Element = PayU3DS2CoreKit.WFBlockModeOption
  public typealias RawValue = Swift.Int
}
@_hasMissingDesignatedInitializers public class SdkEphemPubKey : Swift.Codable {
  public var kty: Swift.String
  public var crv: Swift.String
  public var x: Swift.String
  public var y: Swift.String
  public func getPublicKey() -> Foundation.Data
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension PayU3DS2CoreKit.Warning.Severity : Swift.Equatable {}
extension PayU3DS2CoreKit.Warning.Severity : Swift.Hashable {}
extension PayU3DS2CoreKit.Warning.Severity : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.Warning.WarnReason : Swift.Equatable {}
extension PayU3DS2CoreKit.Warning.WarnReason : Swift.Hashable {}
extension PayU3DS2CoreKit.Warning.WarnReason : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFOFB.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFOFB.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFPKCS5.WFPBKDF2.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFPKCS5.WFPBKDF2.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCCM : PayU3DS2CoreKit.WFBlockMode {}
extension PayU3DS2CoreKit.WFCCM.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCCM.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.AcsInterface : Swift.Equatable {}
extension PayU3DS2CoreKit.AcsInterface : Swift.Hashable {}
extension PayU3DS2CoreKit.AcsInterface : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.AcsUiTemplate : Swift.Equatable {}
extension PayU3DS2CoreKit.AcsUiTemplate : Swift.Hashable {}
extension PayU3DS2CoreKit.AcsUiTemplate : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.PayULoadingType : Swift.Equatable {}
extension PayU3DS2CoreKit.PayULoadingType : Swift.Hashable {}
extension PayU3DS2CoreKit.IndicatorType : Swift.Equatable {}
extension PayU3DS2CoreKit.IndicatorType : Swift.Hashable {}
extension PayU3DS2CoreKit.WFGCM.WFMode : Swift.Equatable {}
extension PayU3DS2CoreKit.WFGCM.WFMode : Swift.Hashable {}
extension PayU3DS2CoreKit.WFGCM.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFGCM.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.ProtocolConstants : Swift.Equatable {}
extension PayU3DS2CoreKit.ProtocolConstants : Swift.Hashable {}
extension PayU3DS2CoreKit.ProtocolConstants : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.AresTxnStatus : Swift.Equatable {}
extension PayU3DS2CoreKit.AresTxnStatus : Swift.Hashable {}
extension PayU3DS2CoreKit.AresTxnStatus : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.MessageType : Swift.Equatable {}
extension PayU3DS2CoreKit.MessageType : Swift.Hashable {}
extension PayU3DS2CoreKit.MessageType : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.MessageCategory : Swift.Equatable {}
extension PayU3DS2CoreKit.MessageCategory : Swift.Hashable {}
extension PayU3DS2CoreKit.MessageCategory : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.TransactionType : Swift.Equatable {}
extension PayU3DS2CoreKit.TransactionType : Swift.Hashable {}
extension PayU3DS2CoreKit.TransactionType : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.DeviceChannel : Swift.Equatable {}
extension PayU3DS2CoreKit.DeviceChannel : Swift.Hashable {}
extension PayU3DS2CoreKit.DeviceChannel : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFSwKeyStore.SecError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFSwKeyStore.SecError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFSwKeyStore.SecError : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFSwKeyConvert.SwError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFSwKeyConvert.SwError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFPEM.EncryptedPrivateKey.EncMode : Swift.Equatable {}
extension PayU3DS2CoreKit.WFPEM.EncryptedPrivateKey.EncMode : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.CCError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.CCError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.CCError : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.DigestAlgorithm : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.DigestAlgorithm : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.DigestAlgorithm : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.HMACAlg : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.HMACAlg : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.HMACAlg : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.OpMode : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.OpMode : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.OpMode : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.BlockMode : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.BlockMode : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.BlockMode : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.AuthBlockMode : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.AuthBlockMode : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.AuthBlockMode : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.Algorithm : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.Algorithm : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.Algorithm : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.Padding : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.Padding : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.Padding : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.RSA.AsymmetricPadding : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.RSA.AsymmetricPadding : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.RSA.AsymmetricPadding : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.RSA.AsymmetricSAPadding : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.RSA.AsymmetricSAPadding : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.RSA.AsymmetricSAPadding : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.DH.DHParam : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.DH.DHParam : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.CRC.Mode : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.CRC.Mode : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.CRC.Mode : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCC.KeyDerivation.PRFAlg : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCC.KeyDerivation.PRFAlg : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCC.KeyDerivation.PRFAlg : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.DeviceRenderInterface : Swift.Equatable {}
extension PayU3DS2CoreKit.DeviceRenderInterface : Swift.Hashable {}
extension PayU3DS2CoreKit.DeviceRenderInterface : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.DeviceRenderUiType : Swift.Equatable {}
extension PayU3DS2CoreKit.DeviceRenderUiType : Swift.Hashable {}
extension PayU3DS2CoreKit.DeviceRenderUiType : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFChaCha20.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFChaCha20.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFDevice.Orientation : Swift.Equatable {}
extension PayU3DS2CoreKit.WFDevice.Orientation : Swift.Hashable {}
extension PayU3DS2CoreKit.WFDevice.CameraTypes : Swift.Equatable {}
extension PayU3DS2CoreKit.WFDevice.CameraTypes : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCTR : PayU3DS2CoreKit.WFBlockMode {}
extension PayU3DS2CoreKit.WFCTR.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCTR.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFAES.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFAES.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFAES.WFVariant : Swift.Equatable {}
extension PayU3DS2CoreKit.WFAES.WFVariant : Swift.Hashable {}
extension PayU3DS2CoreKit.WFAES.WFVariant : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFVariant : Swift.Equatable {}
extension PayU3DS2CoreKit.WFPKCS5.WFPBKDF1.WFVariant : Swift.Hashable {}
extension PayU3DS2CoreKit.WFBit : Swift.Equatable {}
extension PayU3DS2CoreKit.WFBit : Swift.Hashable {}
extension PayU3DS2CoreKit.WFBit : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFSHA2.WFVariant : Swift.Equatable {}
extension PayU3DS2CoreKit.WFSHA2.WFVariant : Swift.Hashable {}
extension PayU3DS2CoreKit.WFSHA2.WFVariant : Swift.Sendable {}
extension PayU3DS2CoreKit.WFOCB.WFMode : Swift.Equatable {}
extension PayU3DS2CoreKit.WFOCB.WFMode : Swift.Hashable {}
extension PayU3DS2CoreKit.WFOCB.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFOCB.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFPCBC.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFPCBC.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.KeyType : Swift.Equatable {}
extension PayU3DS2CoreKit.KeyType : Swift.Hashable {}
extension PayU3DS2CoreKit.KeyType : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.ACSUITypeInt : Swift.Equatable {}
extension PayU3DS2CoreKit.ACSUITypeInt : Swift.Hashable {}
extension PayU3DS2CoreKit.ACSUITypeInt : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.ACSUIType : Swift.Equatable {}
extension PayU3DS2CoreKit.ACSUIType : Swift.Hashable {}
extension PayU3DS2CoreKit.ACSUIType : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFPadding : Swift.Equatable {}
extension PayU3DS2CoreKit.WFPadding : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCipherError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCipherError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFHMAC.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFHMAC.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.ButtonCustomization.ButtonTextTransformType : Swift.Equatable {}
extension PayU3DS2CoreKit.ButtonCustomization.ButtonTextTransformType : Swift.Hashable {}
extension PayU3DS2CoreKit.ButtonCustomization.ButtonTextTransformType : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFBlowfish.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFBlowfish.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCFB.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCFB.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCFB.WFSegmentSize : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCFB.WFSegmentSize : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCFB.WFSegmentSize : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFSHA3.WFVariant : Swift.Equatable {}
extension PayU3DS2CoreKit.WFSHA3.WFVariant : Swift.Hashable {}
extension PayU3DS2CoreKit.EventType : Swift.Equatable {}
extension PayU3DS2CoreKit.EventType : Swift.Hashable {}
extension PayU3DS2CoreKit.WFCBC.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCBC.WFError : Swift.Hashable {}
extension PayU3DS2CoreKit.UiCustomization.ButtonTypeInt : Swift.Equatable {}
extension PayU3DS2CoreKit.UiCustomization.ButtonTypeInt : Swift.Hashable {}
extension PayU3DS2CoreKit.UiCustomization.ButtonTypeInt : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.UiCustomization.ButtonType : Swift.Equatable {}
extension PayU3DS2CoreKit.UiCustomization.ButtonType : Swift.Hashable {}
extension PayU3DS2CoreKit.UiCustomization.ButtonType : Swift.RawRepresentable {}
extension PayU3DS2CoreKit.WFCMAC.WFError : Swift.Equatable {}
extension PayU3DS2CoreKit.WFCMAC.WFError : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension PayU3DS2CoreKit.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension PayU3DS2CoreKit.Reachability.NetworkStatus : Swift.Hashable {}
extension PayU3DS2CoreKit.Reachability.Connection : Swift.Equatable {}
extension PayU3DS2CoreKit.Reachability.Connection : Swift.Hashable {}
